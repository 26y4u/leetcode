### 155. 最小栈

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

- push(x) —— 将元素 x 推入栈中。
- pop() —— 删除栈顶的元素。
- top() —— 获取栈顶元素。
- getMin() —— 检索栈中的最小元素。
- pop、top 和 getMin 操作总是在 非空栈 上调用。

来源：力扣（LeetCode）  
链接：https://leetcode-cn.com/problems/min-stack  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

***  
### 20. 有效的括号

给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。  
有效字符串需满足：
- 左括号必须用相同类型的右括号闭合。  
- 左括号必须以正确的顺序闭合。  
- 注意空字符串可被认为是有效字符串。 

> 输入: "()[]{}"  
> 输出: true   
> 输入: "([)]"  
> 输出: false

 来源：力扣（LeetCode）  
 链接：https://leetcode-cn.com/problems/valid-parentheses  
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
***  

### 739. 每日温度

请根据每日气温列表，重新生成一个列表。对应位置的输出为：要想观测到更高的气温，至少需要等待的天数。如果气温在这之后都不会升高，请在该位置用 0 来代替。

> 输入： temperatures = [73, 74, 75, 71, 69, 72, 76, 73]  
> 输出： [1, 1, 4, 2, 1, 1, 0, 0]

> 提示：气温列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。

来源：力扣（LeetCode）  
链接：https://leetcode-cn.com/problems/daily-temperatures  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。  
***  

### 150. 逆波兰表达式求值

根据 逆波兰表示法，求表达式的值。

有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：  
- 整数除法只保留整数部分。
- 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

> 输入: ["2", "1", "+", "3", "*"]  
> 输出: 9  
> 解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

逆波兰表达式：

- 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。
- 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。
该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。
逆波兰表达式主要有以下两个优点：
- 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。

来源：力扣（LeetCode）  
链接：https://leetcode-cn.com/problems/evaluate-reverse-polish-notation  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
***  

### 133. 克隆图

给你无向连通图中一个节点的引用，请你返回该图的深拷贝（克隆）。  
图中的每个节点都包含它的值val（int）和其邻居的列表（list[Node]）。

```
class Node {
    public int val;
    public List<Node> neighbors;
}
```
测试用例格式：
- 简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。  
- 邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。
- 给定节点将始终是图中的第一个节点（值为 1）。你必须将 给定节点的拷贝 作为对克隆图的引用返回。

> 示例:  
![avatar](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/02/01/133_clone_graph_question.png)
> 输入：adjList = [[2,4],[1,3],[2,4],[1,3]  
> 输出：[[2,4],[1,3],[2,4],[1,3]]  
> 解释：  
> 图中有 4 个节点。  
> 节点 1 的值是 1，它有两个邻居：节点 2 和 4 。  
> 节点 2 的值是 2，它有两个邻居：节点 1 和 3 。  
> 节点 3 的值是 3，它有两个邻居：节点 2 和 4 。  
> 节点 4 的值是 4，它有两个邻居：节点 1 和 3 。

提示：
- 节点数不超过 100 。
- 每个节点值 Node.val 都是唯一的，1 <= Node.val <= 100。
- 无向图是一个简单图，这意味着图中没有重复的边，也没有自环。
- 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。
- 图是连通图，你可以从给定节点访问到所有节点。

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/clone-graph
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
***  

### 494. 目标和

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 + 和 -。对于数组中的任意一个整数，你都可以从 + 或 -中选择一个符号添加在前面。  
返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

> 输入：nums: [1, 1, 1, 1, 1], S: 3  
> 输出：5  
>解释：  
> -1+1+1+1+1 = 3  
> +1-1+1+1+1 = 3  
> +1+1-1+1+1 = 3  
> +1+1+1-1+1 = 3   
> +1+1+1+1-1 = 3  
> 一共有5种方法让最终目标和为3。
  

提示：
- 数组非空，且长度不会超过 20 。
- 初始的数组的和不会超过 1000 。
- 保证返回的最终结果能被 32 位整数存下。

来源：力扣（LeetCode）  
链接：https://leetcode-cn.com/problems/target-sum  
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
***  

### 94. 二叉树的中序遍历
给定一个二叉树，返回它的中序 遍历。

> 输入: [1,null,2,3]  
>       
```
    1
     \
      2
     /
    3
 ```
> 输出: [1,3,2]

来源：力扣（LeetCode）  
链接：https://leetcode-cn.com/problems/binary-tree-inorder-traversal 
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
***  